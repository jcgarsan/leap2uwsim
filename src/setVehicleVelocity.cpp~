/* 
 * Copyright (c) 2013 University of Jaume-I.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Public License v3.0
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/gpl.html
 * 
 * This file has been adapted from setVehicleVelocity.cpp
 * authored by Mario Prats and Javier Perez
 *
 * Contributors:
 *     Juan Carlos Garc√≠a
 */ 


#include <stdlib.h>
#include <string.h>

//ROS
#include <ros/ros.h>
#include <nav_msgs/Odometry.h>

#define TOPIC  "/leap2uwsim/command"

class Leap2Uwsim {

public:
	Leap2Uwsim();

private:
	void leapCallback(const sensor_msgs::Leap::ConstPtr& leap);

	ros::NodeHandle nh_;

	float initPosition[3];
	float initOrientation[4];
	ros::Publisher vel_pub_;
	ros::Subscriber leap_sub_;
};

Leap2Uwsim::Leap2Uwsim() {
	//initializing values
	initPosition[0] = 0;
	initPosition[1] = 0;
	initPosition[2] = 0;
	initOrientation[0] = 0;
	initOrientation[1] = 0;
	initOrientation[2] = 0;
	initOrientation[3] = 0;

	//publisher and subscriber initialization
	vel_pub_ = nh_.advertise<nav_msgs::Odometry>(TOPIC,1);
	leap_sub_ = nh_.subscribe<sensor_msgs::Leap>("leap", 1, &Leap2Uwsim::leapCallback, this);
}


void Leap2Uwsim::leapCallback(const sensor_msgs::Leap::ConstPtr& leap) {

	//Initial user hand position
	if ((initPosition[0] = 0) and (initPosition[1] = 0) and (initPosition[2] = 0)) {
		initPosition[0] = leap.pose.position.x;
		initPosition[1] = leap.pose.position.y;
		initPosition[2] = leap.pose.position.z;
		initOrientation[0] = leap.pose.orientation.x;
		initOrientation[1] = leap.pose.orientation.y;
		initOrientation[2] = leap.pose.orientation.z;
		initOrientation[3] = leap.pose.orientation.w;
	}

	nav_msgs::Odometry odom;
	//Keep all with 0. We send velocities, not position.
	odom.pose.pose.position.x=0.0;
	odom.pose.pose.position.y=0.0;
	odom.pose.pose.position.z=0.0;
	odom.pose.pose.orientation.x=0.0;
	odom.pose.pose.orientation.y=0.0;
	odom.pose.pose.orientation.z=0.0;
	odom.pose.pose.orientation.w=1;

	//For each 10mm of different from users starting point, the velocity increase/decrease
	//initialPosition = (5,10,40); currentPosition = (30,10,40) => odom = (25,0,0) = (2.5,0,0)
	odom.twist.twist.linear.x = (leap.pose.position.x - initPosition[0])/10;
	odom.twist.twist.linear.y = (leap.pose.position.y - initPosition[1])/10;
	odom.twist.twist.linear.z = (leap.pose.position.z - initPosition[2])/10;
	odom.twist.twist.angular.x = (leap.pose.orientation.x - initPosition[0])/10; //roll;
	odom.twist.twist.angular.y = (leap.pose.orientation.y - initPosition[1])/10; //pitch;
	odom.twist.twist.angular.z = (leap.pose.orientation.z - initPosition[2])/10; //yaw;
	for (int i=0; i<36; i++) {
		odom.twist.covariance[i]=0;
		odom.pose.covariance[i]=0;
	}

	vel_pub_.publish(odom);

}



int main(int argc, char **argv) {


  ros::init(argc, argv, "leap2uwsim");
  //TeleopVehicle teleop_vehicle;

  ros::spin();
}
